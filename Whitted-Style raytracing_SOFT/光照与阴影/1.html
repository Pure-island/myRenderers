<!--
!!html_title Basic ray tracing demo - Computer Graphics from scratch
-->
<canvas id="canvas" width=600 height=600 style="border: 1px grey solid">

  <script>
  var canvas = document.getElementById("canvas");
  var canvas_context = canvas.getContext("2d");
  var canvas_buffer = canvas_context.getImageData(0, 0, canvas.width, canvas.height);
  var canvas_pitch = canvas_buffer.width * 4;
  
  // PutPixel()函数.
  var PutPixel = function(x, y, color) {
    x = x + canvas.width/2;
    y = canvas.height/2 - y - 1;//y轴正方向相反
  
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {//超出画布范围不画
      return;
    }
  
    var offset = 4*x + canvas_pitch*y;
    canvas_buffer.data[offset++] = color[0];
    canvas_buffer.data[offset++] = color[1];
    canvas_buffer.data[offset++] = color[2];
    canvas_buffer.data[offset++] = 255; // Alpha = 255 (full opacity)
  }
  
  // 刷新canvas
  var UpdateCanvas = function() {
    canvas_context.putImageData(canvas_buffer, 0, 0);
  }
  
  // 点乘
  var DotProduct = function(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];  
  }
  // 向量相减
  var Subtract = function(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
  }
  
  // 计算模长
  var Length = function(vec) {
    return Math.sqrt(DotProduct(vec, vec));
  }
  
  
  // 计算数乘
  var Multiply = function(k, vec) {
    return [k*vec[0], k*vec[1], k*vec[2]];
  }
  
  
  // 向量相加
  var Add = function(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
  }
  
  // 颜色剪除到0~255
  var Clamp = function(vec) {
    return [Math.min(255, Math.max(0, vec[0])),
      Math.min(255, Math.max(0, vec[1])),
      Math.min(255, Math.max(0, vec[2]))]; 
  }
  
  
  //定义场景
  // 球体
  var Sphere = function(center, radius, color) {
    this.center = center;
    this.radius = radius;
    this.color = color;
  }
  
  // 定义光源
  var Light = function(ltype, intensity, position) {
    this.ltype = ltype;
    this.intensity = intensity;
    this.position = position;
  }
  
  Light.AMBIENT = 0;
  Light.POINT = 1;
  Light.DIRECTIONAL = 2;
  
  
  // 建立场景
  var viewport_size = 1;
  var projection_plane_z = 1;
  var camera_position = [0, 0, 0];
  var background_color = [255, 255, 255];
  var spheres = [
    new Sphere([0, -1, 3.5], 0.7, [255, 0, 0]),
    new Sphere([1.5, 0, 4], 1, [0, 0, 255]),
    new Sphere([-1.5, 0, 4], 1, [0, 255, 0]),
    new Sphere([0, 2, 6], 0.33, [0,0,0]),
    new Sphere([0, 1, 6], 0.33, [255,0,255]),
    new Sphere([0, -5001, 4], 5000, [230, 230, 230])
  ]; 
  var lights = [
    new Light(Light.AMBIENT, 0.2),
    new Light(Light.POINT, 0.6, [2, 1, 0]),
    new Light(Light.DIRECTIONAL, 0.2, [1, 4, 4])
  ];
  
  //将canvas转换到投影平面
  var CanvasToViewport = function(canvasCoord){
      return [
          canvasCoord[0] * viewport_size / canvas.width,
          canvasCoord[1] * viewport_size / canvas.height,
          projection_plane_z
      ];
  }
  
  //光线与球相交
  var IntersectRaySphere = function(origin, direction, sphere){
      var co = Subtract(origin, sphere.center);
      var a = DotProduct(direction,direction);
      var b = 2 * DotProduct(co, direction);
      var c = DotProduct(co, co) - sphere.radius * sphere.radius;
      
      var flag = b*b - 4 * a * c;
      if(flag < 0){
          return [Infinity, Infinity];
      }
  
      var t1 = (-b + Math.sqrt(flag)) / (2 * a);
      var t2 = (-b - Math.sqrt(flag)) / (2 * a);
      return [t1,t2];
  }
  
  var ComputeLighting = function(point, normal){
    var intensity = 0.0;
    
    lights.forEach(element => {
      switch (element.ltype) {
        case Light.AMBIENT:
          intensity += element.intensity;
          break;
        case Light.POINT:
          lightDir = Subtract(element.position, point)
        case Light.DIRECTIONAL:
          lightDir = element.position;//position存的方向
        default:
          n_dot_l = DotProduct(normal, lightDir) / (Length(normal)*Length(lightDir));
          if(n_dot_l > 0){
            intensity += element.intensity * n_dot_l ;
          }
          break;
      }
    });
  
    return intensity;
  
  }
  
  
  //光追
  var TraceRay = function(origin, direction, min_t, max_t){
      var closest_t = Infinity;
      var closest_sphere = null;
  
      spheres.forEach(element => {
          var hit_t = IntersectRaySphere(origin, direction, element);
          if(hit_t[0]<max_t&&hit_t[0]>min_t && hit_t[0]<closest_t){
              closest_t = hit_t[0];
              closest_sphere = element;
          }
          if(hit_t[1]<max_t&&hit_t[1]>min_t && hit_t[1]<closest_t){
              closest_t = hit_t[1];
              closest_sphere = element;
          }
      });
  
      if(closest_sphere == null){
          return background_color;
      }
  
      var point = Add(origin, Multiply(closest_t, direction));
      var normal = Subtract(point, closest_sphere.center);
      normal = Multiply((1.0/Length(normal)),normal);
      return Multiply(ComputeLighting(point,normal),closest_sphere.color);
  }
  
  //
  //Main loop
  //
  for(var x = -canvas.width/2; x < canvas.width/2; x++){
      for(var y = -canvas.height/2; y < canvas.height/2; y++){
          var direction = CanvasToViewport([x,y]);
          var color = TraceRay([0,0,0],direction,1,Infinity);
          PutPixel(x,y,color);
      }
  }
  
  UpdateCanvas();
  
  </script>